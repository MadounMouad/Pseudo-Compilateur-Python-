%token IF ELIF ELSE FOR
%token REEL FIN
%token IN RANGE INT FLOAT NONE AND WHILE BREAK OR PRINT IS RETURN INPUT ADD SUB MULT
%token DIV EQ INFEQ SUPEQ SUP INF AFF NOTEQ PUI DIVENT DIVRES ADDAFF SUBAFF DIVAFF MULTAFF PUIAFF
%token COL SCOL AO AF BO BC PO PF COM DOT DBQ Q ID ENTIER COMMENT SPACE TAB SAUT 

%start input

%%
input: 
| input INST+ 
;

INST: EXP 
| FIN 
| SAUT ;

EXP:  ENTIER 
| PO EXP SUB EXP PF 
| PO EXP MULT EXP PF
| PO EXP DIV EXP PF 
| PO EXP PUI EXP PF 
| PO EXP DIVENT EXP PF 
| PO EXP DIVRES EXP PF 
| PO EXP SUBAFF EXP PF 
| PO EXP PUIAFF EXP PF 
| PO EXP MULTAFF EXP PF 
| PO EXP DIVAFF EXP PF 
| PO EXP ADDAFF EXP PF 
| PO EXP ADD EXP PF 
;
%%

void yyerror(char *s){
    printf("ERREUR SYNTAXIQUE LINE %d\n",yylineno);
}

int main(void){
    yyparse();
    printf("fin de l'analyse syntaxique\n");
    return 0;
}

[\t]*		{
			depth = indent_depth(yytext);
			if(depth < top())
			{
				while (depth < top()) pop();
				yylval.depth = depth;
				return DEDENT;
			}
			if(depth > top())
			{
				push(depth);
				yylval.depth = depth;
				return INDENT;
			}
			
		}



ligne 148 : NOT bool_factor




%left OR
%left AND
%right NOT
%nonassoc INF SUP INFEQ SUPEQ EQ NOTEQ  
%left PUI 
%left MULT DIV DIVENT DIVREST
%left ADD SUB


%right AFF                                         
%nonassoc IF
%nonassoc ELIF
%nonassoc ELSE



letter [A-Za-z]
digit [0-9]
%%
"\n"["\t"" "]*"\n"                  {printf("Empty Line\n");
                                     yyless(yyleng-1);
                                     yylineno++;
                                    }
"\n"["\t"]*"#"[^\n]*                {printf("This is a comment\n");
                                     yylineno++;}
"\n"["\t"]*                         {
                                           if(def_mode == 0){
                                            fprintf(yyout, "%s", yytext);
											yyless(0);
                                            def_mode = 1;
                                            return T_newline;
                                        }else{
                                            if(yyleng-1 == peek(&indent)){
                                                def_mode = 0;
                                                yylineno++;
                                            }else{
                                                if(peek(&indent) < yyleng-1){
                                                    push(&indent, yyleng-1);
                                                    yyless(0);
                                                    printf("Indenting \n");
                                                    return T_indent;
                                                }
                                                if(peek(&indent) > yyleng-1){
                                                    int removed_scope = pop(&indent);
                                                    printTable(removed_scope);
                                                    clearScope(removed_scope);
                                                    printf("Dedenting \n");
                                                    yyless(0);
                                                    return T_dedent;
                                                }
                                            }

                                        }
                                    }
<<EOF>>                             {
                                        fprintf(yyout, "%s", yytext);
                                        if (peek(&indent) != 0){
                                            int removed_scope = pop(&indent);
                                            printTable(removed_scope);
                                            clearScope(removed_scope);
                                            printf("Dedenting EOF \n");
                                            return T_dedent;
                                       }else{
                                            printf("Found EOF\n");
                                            yyterminate();
                                            return T_eof;
                                       }
                                    }
";"                                 {fprintf(yyout, "%s", yytext);return T_semi_colon;}
"="                                 {fprintf(yyout, "%s", yytext);printf("Matches Equal\n"); return T_eq;}
","                                 {fprintf(yyout, "%s", yytext);return T_comma;}
"+="                                {fprintf(yyout, "%s", yytext);return T_plus_eq;}
"-="                                {fprintf(yyout, "%s", yytext);return T_minus_eq;}
"*="                                {fprintf(yyout, "%s", yytext);return T_star_eq;}
"/="                                {fprintf(yyout, "%s", yytext);return T_div_eq;}
"%="                                {fprintf(yyout, "%s", yytext);return T_mod_eq;}
"|="                                {fprintf(yyout, "%s", yytext);return T_or_eq;}
"^="                                {fprintf(yyout, "%s", yytext);return T_xor_eq;}
"del"                               {fprintf(yyout, "%s", yytext);return T_del;}
"pass"                              {fprintf(yyout, "%s", yytext);return T_pass;}
"break"                             {fprintf(yyout, "%s", yytext);return T_break;}
"continue"                          {fprintf(yyout, "%s", yytext);return T_continue;}
"return"                            {fprintf(yyout, "%s", yytext);return T_return;}
"import"                            {fprintf(yyout, "%s", yytext);printf("Matched Import\n"); return T_import;}
"from"                              {fprintf(yyout, "%s", yytext);printf("Matched From\n"); return T_from;}
"*"                                 {fprintf(yyout, "%s", yytext);return T_star;}
"("                                 {fprintf(yyout, "%s", yytext);return T_Lparan;}
")"                                 {fprintf(yyout, "%s", yytext);return T_Rparan;}
"as"                                {fprintf(yyout, "%s", yytext);return T_as;}
"."                                 {fprintf(yyout, "%s", yytext);printf("Matched Dot\n"); return T_dot;}
"if"                                {fprintf(yyout, "%s", yytext);printf("Matched If\n"); return T_if;}
":"                                 {fprintf(yyout, "%s", yytext);printf("Matched Colon\n"); return T_colon;}
"elif"                              {fprintf(yyout, "%s", yytext);return T_elif;}
"else"                              {fprintf(yyout, "%s", yytext);return T_else;}
"for"                               {fprintf(yyout, "%s", yytext);return T_for;}
"in"                                {fprintf(yyout, "%s", yytext);return T_in;}
"or"                                {fprintf(yyout, "%s", yytext);return T_or;}
"and"                               {fprintf(yyout, "%s", yytext);printf("Matched and\n"); return T_and;}
"not"                               {fprintf(yyout, "%s", yytext);return T_not;}
"<"                                 {fprintf(yyout, "%s", yytext);return T_lt;}
">"                                 {fprintf(yyout, "%s", yytext);return T_gt;}
"=="                                {fprintf(yyout, "%s", yytext);return T_deq;}
">="                                {fprintf(yyout, "%s", yytext);return T_ge;}
"<="                                {fprintf(yyout, "%s", yytext);return T_le;}
"!="                                {fprintf(yyout, "%s", yytext);return T_noteq;}
"is"                                {fprintf(yyout, "%s", yytext);return T_is;}
"is"[" "]+"not"                     {fprintf(yyout, "%s", yytext);return T_isnot;}
"not"[" "]+"in"                     {fprintf(yyout, "%s", yytext);return T_notin;}
"|"                                 {fprintf(yyout, "%s", yytext);return T_bitwiseor;}
"&"                                 {fprintf(yyout, "%s", yytext);return T_bitwiseand;}
"^"                                 {fprintf(yyout, "%s", yytext);return T_bitwisexor;}
"<<"                                {fprintf(yyout, "%s", yytext);return T_leftshift;}
">>"                                {fprintf(yyout, "%s", yytext);return T_rightshift;}
"+"                                 {fprintf(yyout, "%s", yytext);return T_plus;}
"-"                                 {fprintf(yyout, "%s", yytext);return T_minus;}
"/"                                 {fprintf(yyout, "%s", yytext);return T_divide;}
"%"                                 {fprintf(yyout, "%s", yytext);return T_mod;}
"//"                                {fprintf(yyout, "%s", yytext);return T_double_divide;}
"~"                                 {fprintf(yyout, "%s", yytext);return T_tilde;}
"**"                                {fprintf(yyout, "%s", yytext);return T_double_star;}
"["                                 {fprintf(yyout, "%s", yytext);return T_squarebleft;}
"]"                                 {fprintf(yyout, "%s", yytext);return T_squarebright;}
"..."                               {fprintf(yyout, "%s", yytext);return T_ellipsis;}
"None"                              {fprintf(yyout, "%s", yytext);return T_none;}
"True"                              {fprintf(yyout, "%s", yytext);return T_true;}
"False"                             {fprintf(yyout, "%s", yytext);return T_false;}
"def"                               {fprintf(yyout, "%s", yytext);return T_def;}
" "+                                {fprintf(yyout, " ");/*Extra Whitespace*/}
({letter}|_)({letter}|_|{digit})*   {
                                       fprintf(yyout, "%s", yytext);
                                       printf("Matched : %s\n", yytext);
                                       int scope = peek(&indent);
                                       char* variable_name = yytext;
                                       symbol_node* temp = NULL;
                                       //printf("Stack Scope: %d\n", peek(&indent));
                                       HASH_FIND_STR(hash_table[scope], variable_name, temp);
                                       //printf("Stack Scope: %d\n", peek(&indent));            
                                       if(temp == NULL){
											temp = malloc(sizeof(symbol_node));
											strcpy(temp->name, variable_name);
											temp->line_no_d = yylineno;
											temp->line_no_used = yylineno;
											temp->type = (char*)malloc(sizeof(char) * 20);
											strcpy(temp->type, "variable");
											temp->storage = (char*)malloc(sizeof(char) * 100);
											strcpy(temp->storage, " ");
											HASH_ADD_STR(hash_table[scope], name, temp);
											printf("Variable Added: %s\n", temp->name);
										}else{
											printf("Variable Found: %s\n", temp->name);
											temp->line_no_used = yylineno;
										}
										//printf("yytext: %s \n", yytext);
										yylval.data = (struct token_structure*)malloc(sizeof(struct token_structure));
										yylval.data->scope = scope;
										yylval.data->name=strdup(yytext);
										//printf("Finished Sending %s %d %s\n", yytext, yylval.data->scope,  yylval.data->name);
                                       return T_name;
                                    }
{digit}+                            {fprintf(yyout, "%s", yytext);printf("Found a number\n"); return T_number;}
\"(.)*\"                            {fprintf(yyout, "%s", yytext);return T_string;}
%%







//-----------------







%start file_input
%token T_name T_number T_string T_newline T_eof T_semi_colon T_eq T_comma T_plus_eq T_minus_eq T_star_eq T_div_eq T_mod_eq T_or_eq T_xor_eq T_del T_pass T_break T_continue T_return T_import T_from T_star T_Lparan T_Rparan T_as T_dot T_if T_colon T_elif T_else T_for T_in T_indent T_dedent T_or T_and T_not T_lt T_gt T_deq T_ge T_le T_noteq T_is T_isnot T_notin T_bitwiseor T_bitwiseand T_bitwisexor T_leftshift T_rightshift T_plus T_minus T_divide T_mod T_double_divide T_tilde T_double_star   T_squarebleft T_squarebright T_ellipsis T_none T_true T_false T_def
%union {struct token_structure* data;};
%left T_and T_or T_in T_notin T_bitwiseor T_bitwiseand
%left T_ge T_le T_eq T_deq T_noteq T_gt T_lt
%left T_plus T_minus
%left T_star T_divide
%%

file_input
	: %empty
	| T_newline file_input
	| stmt file_input
	| T_eof

stmt
	: simple_stmt
	| compound_stmt

simple_stmt
	: small_stmt next_simple_stmt

next_simple_stmt
	: end_simple_stmt
	| T_semi_colon small_stmt next_simple_stmt

end_simple_stmt
	: T_newline
	| T_semi_colon T_newline
	| %empty

small_stmt
	: expr_stmt
	| del_stmt
	| pass_stmt
	| flow_stmt
	| import_stmt

expr_stmt
	: testlist_star_expr next_expr_stmt

next_expr_stmt
	: augassign testlist
	| last_expr_stmt

last_expr_stmt
	: %empty
	| T_eq testlist_star_expr last_expr_stmt

testlist_star_expr
	: first_testlist_star_expr last_testlist_star_expr

first_testlist_star_expr
	: test
	| star_expr

last_testlist_star_expr
	: %empty
	| T_comma end_testlist_star_expr

end_testlist_star_expr
	: %empty
	| test last_testlist_star_expr
	| star_expr last_testlist_star_expr

augassign
	: T_plus_eq
	| T_minus_eq
	| T_star_eq
	| T_div_eq
	| T_mod_eq
	| T_or_eq
	| T_xor_eq

del_stmt
	: T_del	exprlist

pass_stmt
	: T_pass

flow_stmt
	: break_stmt
	| continue_stmt
	| return_stmt

break_stmt
	: T_break

continue_stmt
	: T_continue

return_stmt
	: T_return optional_return

optional_return
	: %empty
	| testlist

import_stmt
	: import_name
	| import_from

import_name
	: T_import dotted_as_names

import_from
	: T_from dotted_name T_import end_import_from

end_import_from
	: T_star
	| T_Lparan import_as_names T_Rparan
	| import_as_names

import_as_name
	: T_name optional_t_name {updateType($<data->scope>1, $<data->name>1, "package_name"); }

optional_t_name
	: %empty
	| T_as T_name {updateType($<data->scope>2, $<data->name>2, "package_alias"); }

dotted_as_name
	: dotted_name optional_t_name

import_as_names
	: import_as_name end_import_as_names

end_import_as_names
	: %empty
	| T_comma import_as_name end_import_as_names

dotted_as_names
	: dotted_as_name end_dotted_as_names

end_dotted_as_names
	: %empty
	| T_comma dotted_as_name end_dotted_as_names

dotted_name
	: T_name optional_dotted_name {updateType($<data->scope>1, $<data->name>1, "package_name"); }

optional_dotted_name
	: %empty
	| T_dot dotted_name

compound_stmt
	: if_stmt
	| for_stmt
	| funcdef

funcdef
	: T_def T_name parameters T_colon suite {updateType($<data->scope>2, $<data->name>2, "function_name"); }

parameters
	: T_Lparan optional_typedargslist T_Rparan

optional_typedargslist
	: %empty
	| typedargslist

typedargslist
	: T_name optional_eq_test repeat_optional_eq_test 

optional_eq_test
	: %empty
	| T_eq test

repeat_optional_eq_test
	: %empty
	| T_comma T_name optional_eq_test repeat_optional_eq_test

if_stmt
	: T_if test T_colon suite elif_stmt optional_else

elif_stmt
	: %empty
	| T_elif test T_colon suite elif_stmt

for_stmt
	: T_for exprlist T_in testlist T_colon suite optional_else

optional_else
	: %empty
	| T_else	T_colon suite

suite
	: simple_stmt
	| T_newline T_indent stmt repeat_stmt T_dedent

repeat_stmt
	: %empty
	| stmt repeat_stmt

test
	: or_test optional_if_else

optional_if_else
	: %empty
	| T_if or_test T_else test

or_test
	: and_test repeat_or_test

repeat_or_test
	: %empty
	| T_or and_test repeat_or_test

and_test
	: not_test repeat_and_test

repeat_and_test
	: %empty
	| T_and not_test repeat_and_test

not_test
	: T_not not_test
	| comparison

comparison
	: expr repeat_comp_expr

repeat_comp_expr
	: %empty
	| comp_op expr repeat_comp_expr

comp_op
	: T_lt
	| T_gt
	| T_deq
	| T_ge
	| T_le
	| T_noteq
	| T_in
	| T_notin
	| T_is
	| T_isnot

star_expr
	: T_star expr

expr
	: xor_expr repeat_expr

repeat_expr
	: %empty
	| T_bitwiseor xor_expr repeat_expr

xor_expr
	: and_expr repeat_xor_expr

repeat_xor_expr
	: %empty
	| T_bitwisexor and_expr repeat_xor_expr

and_expr
	: shift_expr repeat_and_expr

repeat_and_expr
	: %empty
	| T_bitwiseand shift_expr repeat_and_expr

shift_expr
	: arith_expr repeat_shift_expr

repeat_shift_expr
	: %empty
	| T_leftshift arith_expr repeat_shift_expr
	| T_rightshift arith_expr repeat_shift_expr

arith_expr
	: term last_arith_expr

last_arith_expr
	: %empty
	| T_plus term last_arith_expr
	| T_minus term last_arith_expr

term
	: factor last_term

last_term
	: %empty
	| T_star factor last_term
	| T_divide factor last_term
	| T_mod factor last_term
	| T_double_divide factor last_term

factor
	: power
	| T_plus factor
	| T_minus factor
	| T_tilde factor


power
	: atom_expr optional_factor
	
optional_factor
	: %empty
	| T_double_star factor

atom_expr
	: atom repeat_trailer

repeat_trailer
	: %empty
	| trailer repeat_trailer

atom
	: T_Lparan optional_testlist_comp T_Rparan
	| T_squarebleft optional_testlist_comp T_squarebright
	| T_name
	| T_number
	| T_string repeat_string
	| T_ellipsis
	| T_none
	| T_true
	| T_false

optional_testlist_comp
	: %empty
	| testlist_comp

repeat_string
	: %empty
	| T_string repeat_string

testlist_comp
	: first_testlist_comp last_testlist_comp

first_testlist_comp
	: test
	| star_expr

last_testlist_comp
	: repeat_testlist_comp optional_comma

repeat_testlist_comp
	: %empty
	| T_comma end_testlist_comp

end_testlist_comp
	: test repeat_testlist_comp
	| star_expr repeat_testlist_comp

trailer
	: T_Lparan optional_arglist T_Rparan
	| T_Lparan optional_typedargslist T_Rparan
	| T_squarebleft subscriptlist T_squarebright
	| T_dot T_name

optional_arglist
	: %empty
	| arglist

subscriptlist
	: subscript repeat_subscript optional_comma

repeat_subscript
	: %empty
	| T_comma subscript repeat_subscript

subscript
	: test
	| optional_test T_colon optional_test optional_sliceop

optional_test
	: %empty
	| test

optional_sliceop
	: %empty
	| sliceop

sliceop
	: T_colon optional_test

exprlist
	: first_exprlist last_exprlist optional_comma

first_exprlist
	: expr
	| star_expr

last_exprlist
	: %empty
	| T_comma first_exprlist last_exprlist

optional_comma
	: %empty
	| T_comma

testlist
	: test repeat_test optional_comma

repeat_test
	: %empty
	| T_comma test repeat_test

arglist
	: argument repeat_argument optional_comma

repeat_argument
	: %empty
	| T_comma argument repeat_argument

argument
	: test T_eq test
	| T_double_star test
	| T_star test